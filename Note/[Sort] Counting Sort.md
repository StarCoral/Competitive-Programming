# [Sort] Counting Sort

## How to do?

計數排序法的想法有別於一般的sort方法，非【比較】兩元素間的大小，  
而是先計算在該序列中元素(或其作為排序依據的屬性)出現的次數，再利用次數資訊去排序。  
```
**待排序的陣列**  
索引    0   1   2   3   4   5   6   7   8  
數值    9   8   3   3   9   2   4   6   3  
```
+ **Step 1 計算次數**
由於待排序陣列的元素都是0~9中的一個整數數值，  
因此陣列元素有(9 - 0 + 1) = 10種可能的數值，  
所以要建立出一個大小為10的整數陣列來儲存計數排序法要用的次數資訊。  

此陣列索引i的位置用來儲存元素i在待排序陣列中出現的次數。計算之後我們得到了如下的計數陣列：
```
**計數陣列**
索引(數值)    0   1   2   3   4   5   6   7   8   9
數值(次數)    0   0   1   3   1   0   1   0   1   2
```
+ **Step 2-1 Counting Sort(不穩定)**

//in-place
適用在被排序的元素就是用來作為排序依據的數值  

利用次數資訊開始將元素值填寫進原陣列中。   
接著就開始把數值依序填進這個相同的序列中，  
0個0，不填。  
0個1，不填。  
首先填入1個2，序列內容會變成[2, 8, 3, 3, 9, 2, 4, 6, 3 ]。  
再來填入3個3，序列內容會變成[2, 3, 3, 3, 9, 2, 4, 6, 3 ]。  
再來填入1個4，序列內容會變成[2, 3, 3, 3, 4, 2, 4, 6, 3 ]。  
0個5，不填。  
再來填入1個6，序列內容會變成[2, 3, 3, 3, 4, 6, 4, 6, 3 ]。  
0個7，不填。  
再來填入1個8，序列內容會變成[2, 3, 3, 3, 4, 6, 8, 6, 3 ]。  
最後填入2個9，序列內容會變成[2, 3, 3, 3, 4, 6, 8, 9, 9 ]。  

+ **Step 2-1 Counting Sort(穩定)**

在取得次數資訊之後，還要先利用這個次數資訊來計算出元素的位置資訊。  

同樣以剛才的序列來舉例，可以藉由照順序走訪並累加每次迭代時的此項和前項的次數，來得出「有0 + 1 = 1個元素<=2」、「有1 + 3 = 4個元素<=3」、「有4 + 1 = 5個元素小於等於4」、「有5 + 0 = 5個元素<=5」、「有5 + 1 = 6個元素<=6」、「有6 + 0 = 6個元素<=7」、「有6 + 1 = 7個元素<=8」、「有7 + 2 = 9個元素<=9」這樣的位置資訊。  

```
**待排序的陣列**  
索引    0   1   2   3   4   5   6   7   8  
數值    9   8   3   3   9   2   4   6   3  
```

```
**計數陣列**
索引(數值)    0   1   2   3   4   5   6   7   8   9
數值(次數)    0   0   1   4   5   5   6   6   7   9
```

接著產生出另一個相同大小的空序列，並從原序列的尾端向前開始走訪這個原序列。  
一開始會看到元素1，根據位置資訊「有7 + 2 = 9個元素<=9」，我們可以直接把這個原序列的元素1複製進新序列的第9個位置(也就是索引8的位置)，此時新序列的內容為[?, ?, ?, ?, ?, ?, ?, ?, 9 ]，且位置資訊修改為「有9 - 1 = 8個元素<=9」，然後再繼續下次的迭代，重複一樣的動作，排序的結果就會存在新序列中了。


### Time Complexity

n:要排序的資料筆數。  
k:要排序的資料可能的值的數量。  

+ Best Case：Ο(n+k)  
+ Worst Case：Ο(n+k)   
+ Average Case：Ο(n+k)  


## Space Complexity

+ θ(k) //in-place，不穩定
+ θ(n+k) //not in-place，穩定


## Practice

+ LC#75

## Reference

https://magiclen.org/counting-sort/
